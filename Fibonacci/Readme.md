# N번째 Fibonacci 수
github 데탑 클라이언트로 커밋하면 한글주석 깨지는거 열받네ㅡㅡ

### 여기가 어디죠?
 자연수 n이 주어지면 **N번째 피보나치 수**를 구하는 코드들의 모음이며, 이 문서는 그 코드들에 대한 설명입니다. 

### 들어가기 앞서

1. 1번째와 2번째 피보나치 수는 1입니다.
2. 입력/출력으로 들어가는 자연수 n은 int로 선언되어 있습니다.
3. n은 자연수로 가정하고 있기 때문에 n < 1인 경우 또는 n > MAX_INT일 때의 돌발상황은 고려하지 않은 코드들이 있습니다(향후 고칠수도?).
4. 주석은 전부 제 뇌피셜입니다.

## 재귀

피보나치를 처음 구현할 때 흔히 사용하는 방법입니다.

### 단순 재귀
    
    int fibo(int n)
    {
	    if (n == 1 || n == 2) { return 1; }
    	else return fibo(n - 2) + fibo(n - 1);
    }
가장 정의에 충실한 직관적인 코드입니다.  $O(2^n)$ 방법

이 코드는 한번 실행에 함수가 두개씩 딸려나온다는 점 때문에 n이 커질수록 위험합니다.  [관련해서 백준 문제(1003번)도 있더라구요.](https://www.acmicpc.net/problem/1003) 


## 꼬리 재귀

재귀가 콜 스택을 깊게 사용할수록 메모리 오버헤드 문제에서 위험하기 때문에 
일단 입력으로 변수를 하나만 받기로 했으니, wrapper 함수를 만들어줍시다.

	int fibo_TailRecursive(int n)
	{
		return fibo_TailRecursive_inner(n, 1, 1);
	}

아래는 내부 구현입니다.

	int fibo_Tail_inner(int n, int a, int b)
	{
		if (n == 1 || n == 2) { return b; }
		else return { fibo_Tail_inner(n - 1, b , a + b) };
	}

fibonacci.cpp 맨 위에 있는 fibo_loop함수의 알고리즘을 이용했습니다.
함수형 언어 중 순수성이 높은 언어면 아예 반복문도 제공하지 않고 이런식으로  프로그래머에게 꼬리 재귀를 이용하여 구현할 것을 요구하는 언어도 있다고 합니다.

컴파일러가 똑똑하면 꼬리재귀를 컴파일 시간에 최적화도 제공해줍니다. 
  gcc는 -O를 세게 주고, Visual Studio는 해당 옵션을 체크해줘야 하는걸로 알고 있습니다.


## 동적 계획법
$O(n)$ 방법입니다. 동적 계획법의 주 아이디어는 다음과 같습니다.

1. 기존에 계산하던 결과가 있으면 가져다 쓴다.
2. 없으면 그때 새로 계산한다.




## $O(1)$ 방법...?
제목은 어그로입니다.
컴파일러에게 연산을 짬때려버리는 방법입니다.  _런타임에서는_  상수처럼 쓸 수 있지만, 컴파일 단계에서 상수성이 확정되어야 하기 때문에 main에서 헤더 파일을 include한다는 가정하에 헤더 파일에 정의했습니다.

### TMP

### constexpr
키워드에 const를 이용하면 컴파일러가 키워드를 무시하고 런타임에서 연산을 걸 수도 있습니다. constexpr는 const보다 좀 더 상수성이 강조되어 있습니다.

## $O(\log{}n)$ 방법
선형대수, 정수론 지식을 이용해서 구하는 방법입니다.
피보나치에 특화된 수학적인 내용이 필요한 방법이라 PS외에 응용하기 쉬워보이진 않네요.

### 행렬 이용

### 점화식의 일반해


## 멀티쓰레드
시험삼아 시도해봤지만 끔찍한 성능 때문에 간단하게만 짚고 넘어가겠습니다.


